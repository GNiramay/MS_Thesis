#define AnalyzeHGCOctTB_cxx

#include <iostream>
#include <vector>
#include <cstring>
#include "AnalyzeHGCOctTB.h"
#include "Math/SMatrix.h"
#include "Math/SVector.h"
#include <math.h>

using namespace std;
// chip 3022,44,3028

int main(int argc, char* argv[])
{

  if (argc < 6) {
    cerr << "Please give 5 arguments " << "runList " << " " << "outputFileName" << " " << "dataset" <<" " << "configuration" 
	 <<" " << "energy" << endl;
    return -1;
  }
  const char *inputFileList = argv[1];
  const char *outFileName   = argv[2];
  const char *data          = argv[3];
  const char *config          = argv[4];
  const char *energy = argv[5];
  AnalyzeHGCOctTB hgcOctTB(inputFileList, outFileName, data, config, energy);
  cout << "dataset " << data << " " << endl;
  cout << "configuration " << config << " " << endl;
  cout << "energy " << energy << " " << endl;

  hgcOctTB.EventLoop(data);
  return 0;
}

void AnalyzeHGCOctTB::EventLoop(const char *data) {

  int MyComp(int,float*);		// Sorting layers into convenient compartments

  if (fChain == 0) return;

  Long64_t nentries = fChain->GetEntriesFast();
  // Long64_t nentries3 = fChain3->GetEntriesFast();
  Long64_t hgc_jentry = 0;

  cout << "nentries " << nentries << endl;
  cout << "Analyzing dataset " << data << " " << endl;

  Long64_t nbytes = 0, nb = 0;
  Long64_t nbytes2 = 0, nb2 = 0;
  // Long64_t nbytes3 = 0, nb3 = 0;


  Long64_t region_1_classified_events = 0;
  Long64_t region_2_classified_events = 0;
  Long64_t region_3_classified_events = 0;
  Long64_t non_classified_events = 0;

  int decade = 0;
  int ahc_zeroHit = 0;

  float lambda[40] =  {0.038, 0.1, 0.135, 0.197, 0.231, 
  		       0.293, 0.328, 0.39, 0.424, 0.486, 
  		       0.521, 0.583, 0.617, 0.679, 0.714, 
  		       0.776, 0.81, 0.872, 0.907, 0.969,
  		       1.003, 1.081, 1.116, 1.193, 1.228, 
  		       1.301, 1.335, 1.409, 1.71, 2.011,
  		       2.312, 2.614, 2.915, 3.208, 3.319, 
  		       3.62, 3.921, 4.226, 4.522, 4.816};
  //in mm
  float ahc_pos[39] = {27.45, 53.65, 79.85, 106.05, 132.25, 
		       158.45, 184.65,210.85,237.05, 263.25,
		       289.45, 315.65, 341.85, 368.05, 394.25,
		       420.45, 446.65, 472.85, 499.05, 525.25,
		       551.45, 577.65, 603.85, 630.05, 656.25, 
		       682.45, 708.65, 734.85, 761.05, 787.25,
		       813.45, 839.65, 865.85, 892.05, 918.25, 
		       944.45, 970.65, 996.85, 1075.45};
  //in cm
  float ahc_front = 169.9;


  bool DEBUG = false;
  Long64_t cut_count[28];
  Long64_t nEvents = 0;
  Long64_t MIP_pions = 0;
  int TOTAL_ACTIVE_LAYER = -1;
  int EE_LAYER = -1;
  int FH_LAYER = -1;
  if(!strcmp(conf_,"alpha") || !strcmp(conf_,"config1")) {
    TOTAL_ACTIVE_LAYER = 40;
    EE_LAYER = 28;
    FH_LAYER = 12;
  }
  else if(!strcmp(conf_,"bravo") || !strcmp(conf_,"config2")){
    TOTAL_ACTIVE_LAYER = 39;
    EE_LAYER = 28;
    FH_LAYER = 11;
  }
  else if(!strcmp(conf_,"charlie") || !strcmp(conf_,"config3")) {
    TOTAL_ACTIVE_LAYER = 20;
    EE_LAYER = 8;
    FH_LAYER = 12;
  }
  else {
    cout<<"ERROR: Unknown configuration!!!!"<<endl;
    return;
  }




  double E_beam = -1.0;




  if(DEBUG) cout<<"DEBUG: Configuration = "<<conf_<<endl;
  if(DEBUG) cout<<"DEBUG: TOTAL_ACTIVE_LAYER = "<<TOTAL_ACTIVE_LAYER<<endl;
  if(DEBUG) cout<<"DEBUG: EE_LAYER = "<<EE_LAYER<<endl;
  if(DEBUG) cout<<"DEBUG: FH_LAYER = "<<FH_LAYER<<endl;

  if(DEBUG) cout<<"DEBUG: Entering event Loop"<<endl;
  for(int i = 0; i< 28; i++){ cut_count[i] = 0;}
  Long64_t jentry = 0;;
  for (jentry=0; jentry<nentries;jentry++) {
    // ==============print number of events done == == == == == == == =
    double progress = 10.0 * jentry / (1.0 * nentries);
    int k = int (progress);
    if (k > decade)
      cout << 10 * k << " %" << endl;
    decade = k;
    
    // ===============read this entry == == == == == == == == == == ==

    Long64_t ientry = LoadTree(jentry);
    if (ientry < 0) { break; cout<<"Breaking"<<endl;}
        // cout<<"****"<<endl;
    nb = fChain->GetEntry(jentry);   nbytes += nb;
    nb2 = fChain2->GetEntry(jentry); nbytes2 += nb2;
    // nb3 = fChain3->GetEntry(jentry); nbytes3 += nb3;

    if(NRechits == 0) continue;
    // if(NRechits > 50 || NRechits < 20) continue;
    // h_nTracks->Fill(ntracks);
    if(ntracks != 1) continue;
    E_beam = beamEnergy;
    
    // h_particleID->Fill(pdgID);
    // h_runNumber->Fill(run);
    // h_beamEnergy->Fill(trueBeamEnergy);

    const int TOTAL_LAYERS = 79;
    Float_t track_x[TOTAL_LAYERS];
    Float_t track_y[TOTAL_LAYERS];

    track_x[0] = impactX_HGCal_layer_1;
    track_y[0] = impactY_HGCal_layer_1;
    track_x[1] = impactX_HGCal_layer_2;
    track_y[1] = impactY_HGCal_layer_2;
    track_x[2] = impactX_HGCal_layer_3;
    track_y[2] = impactY_HGCal_layer_3;
    track_x[3] = impactX_HGCal_layer_4;
    track_y[3] = impactY_HGCal_layer_4;
    track_x[4] = impactX_HGCal_layer_5;
    track_y[4] = impactY_HGCal_layer_5;
    track_x[5] = impactX_HGCal_layer_6;
    track_y[5] = impactY_HGCal_layer_6;
    track_x[6] = impactX_HGCal_layer_7;
    track_y[6] = impactY_HGCal_layer_7;
    track_x[7] = impactX_HGCal_layer_8;
    track_y[7] = impactY_HGCal_layer_8;
    track_x[8] = impactX_HGCal_layer_9;
    track_y[8] = impactY_HGCal_layer_9;
    track_x[9] = impactX_HGCal_layer_10;
    track_y[9] = impactY_HGCal_layer_10;
    track_x[10] = impactX_HGCal_layer_11;
    track_y[10] = impactY_HGCal_layer_11;
    track_x[11] = impactX_HGCal_layer_12;
    track_y[11] = impactY_HGCal_layer_12;
    track_x[12] = impactX_HGCal_layer_13;
    track_y[12] = impactY_HGCal_layer_13;
    track_x[13] = impactX_HGCal_layer_14;
    track_y[13] = impactY_HGCal_layer_14;
    track_x[14] = impactX_HGCal_layer_15;
    track_y[14] = impactY_HGCal_layer_15;
    track_x[15] = impactX_HGCal_layer_16;
    track_y[15] = impactY_HGCal_layer_16;
    track_x[16] = impactX_HGCal_layer_17;
    track_y[16] = impactY_HGCal_layer_17;
    track_x[17] = impactX_HGCal_layer_18;
    track_y[17] = impactY_HGCal_layer_18;
    track_x[18] = impactX_HGCal_layer_19;
    track_y[18] = impactY_HGCal_layer_19;
    track_x[19] = impactX_HGCal_layer_20;
    track_y[19] = impactY_HGCal_layer_20;
    track_x[20] = impactX_HGCal_layer_21;
    track_y[20] = impactY_HGCal_layer_21;
    track_x[21] = impactX_HGCal_layer_22;
    track_y[21] = impactY_HGCal_layer_22;
    track_x[22] = impactX_HGCal_layer_23;
    track_y[22] = impactY_HGCal_layer_23;
    track_x[23] = impactX_HGCal_layer_24;
    track_y[23] = impactY_HGCal_layer_24;
    track_x[24] = impactX_HGCal_layer_25;
    track_y[24] = impactY_HGCal_layer_25;
    track_x[25] = impactX_HGCal_layer_26;
    track_y[25] = impactY_HGCal_layer_26;
    track_x[26] = impactX_HGCal_layer_27;
    track_y[26] = impactY_HGCal_layer_27;
    track_x[27] = impactX_HGCal_layer_28;
    track_y[27] = impactY_HGCal_layer_28;
    track_x[28] = impactX_HGCal_layer_29;
    track_y[28] = impactY_HGCal_layer_29;
    track_x[29] = impactX_HGCal_layer_30;
    track_y[29] = impactY_HGCal_layer_30;
    track_x[30] = impactX_HGCal_layer_31;
    track_y[30] = impactY_HGCal_layer_31;
    track_x[31] = impactX_HGCal_layer_32;
    track_y[31] = impactY_HGCal_layer_32;
    track_x[32] = impactX_HGCal_layer_33;
    track_y[32] = impactY_HGCal_layer_33;
    track_x[33] = impactX_HGCal_layer_34;
    track_y[33] = impactY_HGCal_layer_34;
    track_x[34] = impactX_HGCal_layer_35;
    track_y[34] = impactY_HGCal_layer_35;
    track_x[35] = impactX_HGCal_layer_36;
    track_y[35] = impactY_HGCal_layer_36;
    track_x[36] = impactX_HGCal_layer_37;
    track_y[36] = impactY_HGCal_layer_37;
    track_x[37] = impactX_HGCal_layer_38;
    track_y[37] = impactY_HGCal_layer_38;
    track_x[38] = impactX_HGCal_layer_39;
    track_y[38] = impactY_HGCal_layer_39;
    track_x[39] = impactX_HGCal_layer_40;
    track_y[39] = impactY_HGCal_layer_40;

    for(int j = 0; j < 39; j++) {
      double z = ahc_front + (ahc_pos[j]/10.0) ;
      double x = (z * m_x) + b_x;
      double y = (z * m_y) + b_y;

      track_x[j+40] = x;
      track_y[j+40] = y;
    }


    Double_t rechitEnergySum = 0.0;
    // Double_t rechitEnergySum_mip_cut = 0.0;
    Double_t un_cali = 0.0;
    Long_t Nrechit_layer[40];
    // Long_t NRechits_EE[28];
    // Long_t NRechits_FH[12][7];

    Long_t NRechits_EE[28];
    Long_t NRechits_FH[12];
    Long_t NRechits_AH[39];

    Double_t RechitsEn_EE[28];
    Double_t RechitsEn_FH[12];
    Double_t RechitsEn_AH[39];
    Double_t RechitEn_layer[40];

    int module_part_ = -1;
    int module_layer_ = -1;
    int module_position_ = -1;

    double energy_sum_dR2_[40];
    double cogX_[40];
    double cogY_[40];
    
    for(int ii=0;ii<40;ii++){
      if(ii<28) {
	NRechits_EE[ii]=0;
	RechitsEn_EE[ii] = 0.0;
	// dR[ii].clear();
	// dr_min_index[ii] = -1.0;
	// dr_min[ii] = 1.e10;
      }
      else{
	NRechits_FH[ii-28]=0;
	RechitsEn_FH[ii-28] = 0.0;
      }
      Nrechit_layer[ii]=0;
      energy_sum_dR2_[ii] = 0.0;
      RechitEn_layer[ii] = 0.0;
      cogX_[ii] = -1.0;
      cogY_[ii] = -1.0;
      // dR[ii].clear();
      // dr_min_index[ii] = -1.0;
      // dr_min[ii] = 1.e10;
      if(ii < 39) {
	RechitsEn_AH[ii] = 0.0;
	NRechits_AH[ii] = 0;
      }

    }

    /// FIll Tree
    if(DEBUG) cout<<"DEBUG: Start Analylizing RecHits!!"<<endl;
    if(DEBUG) cout<<"DEBUG: NRechits = "<<NRechits<<endl;

    std::vector<int> temp_moduleID;
    int Nrech_L1[4] = {0,0,0,0};
    for(int i = 0 ; i < NRechits; i++){
      temp_moduleID.clear();
      int temp_layer = rechit_layer->at(i);
      int temp_chip = rechit_chip->at(i);
      int temp_channel = rechit_channel->at(i);
      int en_chan = temp_chip*1000+temp_channel;
      
      double recx = rechit_x->at(i);
      double recy = rechit_y->at(i);
      
      //channel masking
      if(en_chan == 3022 || en_chan == 3028 || en_chan == 44) continue;
      if(temp_layer==1 && temp_chip==0) continue;
      if(temp_layer==1) {
	Nrech_L1[temp_chip]++;
      }
      
      // noise cut
      std::pair<float, float> temp_mod_chip((int)rechit_module->at(i),(int)rechit_chip->at(i));
      float noise_chip = getNoise(temp_mod_chip);
      if(DEBUG) cout<<"Module, layer, chip , noise = "<<rechit_module->at(i)<<", "<<rechit_layer->at(i)<<", "<<rechit_chip->at(i)<<", "<<noise_chip<<endl;
      if(rechit_amplitudeHigh->at(i) < 3*noise_chip)
	continue;
      
      double trackx = track_x[temp_layer-1];
      double tracky = track_y[temp_layer-1];
      if(temp_layer == 2)

      if(!strcmp(data,"data")) {
	trackx = -1*trackx;
	tracky = -1*tracky;
	std::pair<float, float> dxy_al = dxy_alignment(temp_layer);
	float dx_corr = dxy_al.first;
	float dy_corr = dxy_al.second; 
	recx -= dx_corr;
	recy -= dy_corr;	
      }
      
      // else if(!strcmp(data,"sim")) {
      // 	if(rechit_amplitudeHigh->at(i) < 18) continue;
      // 	//if(rechit_module->at(i) == 42) continue;
      // }
      Nrechit_layer[temp_layer-1]++;
      RechitEn_layer[temp_layer-1]+=rechit_energy->at(i);
      
      temp_moduleID = getModuleLocation(rechit_module->at(i));
      
      cogX_[temp_layer-1] += (rechit_x->at(i)*rechit_energy->at(i));
      cogY_[temp_layer-1] += (rechit_y->at(i)*rechit_energy->at(i));



      if((temp_layer==38 && rechit_module->at(i)!=62) || (temp_layer==39 && rechit_module->at(i)!=54) || (temp_layer==40 && rechit_module->at(i)!=43)){
	cout<< jentry+1 << " = " << rechit_module->at(i)<<endl;
      }


      if(!temp_moduleID.size() || temp_moduleID.size()<3) {
	cout<<"ERROR: Could NOT locate MODULE location for module "<<rechit_module->at(i)<<endl;
	cout<<"\t more info temp_moduleID.size() = "<<temp_moduleID.size()<<endl;
	return;
      }
      module_part_ = temp_moduleID.at(0);
      module_layer_ = temp_moduleID.at(1);
      module_position_ = temp_moduleID.at(2);

      // h_moduleID->Fill(module_part_);

      /////////////////// shower finding algo ////////
      
      double dR = deltaR(recx,recy,trackx,tracky);
      if(dR < 2.0) {
	// cout<<"#######NOTICE ME SENPAI*********HELLLOOOO"<<endl;
	energy_sum_dR2_[temp_layer-1]+=rechit_energy->at(i);
      }
      
      if(module_part_ == 0) {
	// rechitEnergySum_EE+=rechit_energy->at(i);
	RechitsEn_EE[module_layer_-1]+=rechit_energy->at(i);
	NRechits_EE[module_layer_-1]++;
      }
      else if(module_part_ == 1) {
	// rechitEnergySum_FH+=rechit_energy->at(i);
	RechitsEn_FH[module_layer_-1]+=rechit_energy->at(i);
	NRechits_FH[module_layer_-1]++;
	
      }
      else {
	cout<<"ERROR: Unknown Module Part detected!!!!"<<endl;
	return;
	
      }
      rechitEnergySum+=rechit_energy->at(i);
      
    }


    ////////////////////////////////////////////
    //            AHCAL Part                  //
    ////////////////////////////////////////////
    
    Double_t rechitEnergySumAHCAL = sim_energyAH;
    // for(int i = 0 ; i < ahc_nHits; i++) {
    //   int temp_layer = ahc_hitK->at(i);
    //   RechitsEn_AH[temp_layer -1] += ahc_hitEnergy->at(i);
    //   rechitEnergySumAHCAL += ahc_hitEnergy->at(i);
    //   NRechits_AH[temp_layer -1]++;
    // }

    /////////////////////////////////////////////

    if(DEBUG) cout<<"DEBUG: For shower start"<<endl;
    if(DEBUG && false) {
      for (int ll = 0; ll < 40; ll++) {
	cout<<ll+1<<"\t"<<energy_sum_dR2_[ll]<<endl;
      }
    }
    
    /////////////////// shower finding algo ////////
    bool MIP = true;
    int shower_start_index = -1;
    float shower_lambda_ = -1.0;
    float shower_weight_ = 1.0;
    if(energy_sum_dR2_[0] > 20) {
      // cout<<"Shower started in layer =1"<<endl;
      shower_start_index = 0;
      shower_lambda_ = lambda[0];
      shower_weight_ = lambda[0];
      MIP = false;
    }
    
    else if(energy_sum_dR2_[1] > 20 && energy_sum_dR2_[1] > 2*energy_sum_dR2_[0]) {
      // cout<<"Shower started in layer =2"<<endl;
      shower_start_index = 1;
      shower_lambda_ = lambda[1];
      shower_weight_ = lambda[1]-lambda[0];
      MIP = false;
    }
    
    else {
      
      for(int i = 2; i < 40; i++) {
	if((energy_sum_dR2_[i] > 20) && (energy_sum_dR2_[i] > 2*energy_sum_dR2_[i-1]) && (energy_sum_dR2_[i] > 2*energy_sum_dR2_[i-2])) {

	  // if(i+1==27 || i+1==28) {
	  //   cout<<"Shower started in layer ="<<i+1<<" ,lambda_ = "<<lambda[i]<<endl;
	  // }
	  shower_start_index = i;
	  shower_lambda_ = lambda[i];
	  shower_weight_ = lambda[i]-lambda[i-1];
	  MIP = false;
	  break;
	}
      }
    }
    ///////////////////////////////////////////////
    //       Niramay - Compartmentalising        //
    ///////////////////////////////////////////////
    int COMP = MyComp(shower_start_index,lambda);


    ///////////////////////////////////////////////
    //                Collapsed EE               //
    ///////////////////////////////////////////////
    if(shower_start_index+1 <= 28 && (shower_start_index+1) > 0) {
      // cout<<""
      // h_shower_start_full_collapsed_EE->Fill(lambda[0]);
      if((shower_start_index+1)%2 == 0) {
    	// h_shower_start_part_collapsed_EE->Fill(lambda[shower_start_index-1]);
    	// cout<<shower_start_index<<" "<<(shower_start_index+1)%2<<" "<<shower_start_index-1<<" "<<lambda[(shower_start_index+1)/2]<<endl;
      }
      else {
    	// h_shower_start_part_collapsed_EE->Fill(lambda[shower_start_index]);
      }
    }
    else {
      // h_shower_start_full_collapsed_EE->Fill(shower_lambda_);
      // h_shower_start_part_collapsed_EE->Fill(shower_lambda_);
    }

    if(DEBUG) cout<<"DEBUG: Shower start index = "<<shower_start_index<<endl;

    ///////////////////////////////////////////////
    // if(jentry > 50)
    //   return;



    Long_t Nrechit_EE = 0;
    Long_t Nrechit_FH = 0;
    Double_t rechitEnergySum_EE = 0.0;
    Double_t rechitEnergySum_FH = 0.0;
    Double_t test = 0.0;
    bool zero_rh[40];
    
    // cout<<"*** NEW EVENT="<<jentry+1<<",shower_start="<<shower_start_index<<" ***"<<endl;
    // cout<<"layer:track(x,y):cog(x,y)"<<endl;
    for(int iL = 0; iL < TOTAL_ACTIVE_LAYER; iL++){
      if(iL < EE_LAYER) {
	Nrechit_EE+=NRechits_EE[iL];
	rechitEnergySum_EE+=RechitsEn_EE[iL];
	cogX_[iL] = cogX_[iL]/RechitsEn_EE[iL];
	cogY_[iL] = cogY_[iL]/RechitsEn_EE[iL];
      }
      else {
	Nrechit_FH+=NRechits_FH[iL-EE_LAYER];
	rechitEnergySum_FH+=RechitsEn_FH[iL-EE_LAYER];
	cogX_[iL] = cogX_[iL]/RechitsEn_FH[iL-EE_LAYER];
	cogY_[iL] = cogY_[iL]/RechitsEn_FH[iL-EE_LAYER];
	
      }
      
      //cout<<iL+1<<":("<<track_x[iL]<<","<<track_y[iL]<<"):("<<cogX_[iL]<<","<<cogY_[iL]<<")"<<endl;
    }
    
    //if(jentry > 5) return;
    if(DEBUG) cout<<"DEBUG: NRechits in EE = "<<Nrechit_EE<<"\t Rechit_energy in EE = "<<rechitEnergySum_EE<<endl;
    if(DEBUG) cout<<"DEBUG: NRechits in FH = "<<Nrechit_FH<<"\t Rechit_energy in FH = "<<rechitEnergySum_FH<<endl;
   
    double isMuonLike = false;
    bool isRegion1 = false;
    bool isRegion2 = false;
    bool isRegion3 = false;

    if(shower_start_index == -1) {  //MIP LIKE
      isRegion1 = true;
      isRegion2 = false;
      isRegion3 = false;
      // h_shower_start_reg1->Fill(shower_lambda_);
      region_1_classified_events++;
    }
    else if(shower_start_index > 27) { //H hadrons
      isRegion1 = false;
      isRegion2 = true;
      isRegion3 = false;
      // h_shower_start_reg2->Fill(shower_lambda_);
      region_2_classified_events++;
    }
    else {  //EH hadron
      isRegion1 = false;
      isRegion2 = false;
      isRegion3 = true;
      // h_shower_start_reg3->Fill(shower_lambda_);
      region_3_classified_events++;
    }

    float LEAK = energyLeakTransverseEE + energyLeakTransverseFH + energyLeakTransverseAH;
    float EABS = energyLostEE + energyLostFH + energyLostBH;
    // if(shower_start_index>-1) LeakFr_Abs[shower_start_index]->Fill(EABS,(LEAK)/(EABS));
    if(shower_start_index>-1)
      {
	// if(shower_start_index<28) LeakFr_Abs[shower_start_index]->Fill(energyLostEE,(LEAK)/(beamEnergy));
	// else LeakFr_Abs[shower_start_index]->Fill(energyLostFH,(LEAK)/(beamEnergy));
	LeakFr_EE[COMP]->Fill(rechitEnergySum_EE,(LEAK)/(beamEnergy));
	LeakFr_FH[COMP]->Fill(rechitEnergySum_FH,(LEAK)/(beamEnergy));
      }
    if(isRegion2) {
      double a = -1.0;
      double b = -1.0;
      // double a = 0.0611934;
      // double b = 0.0183451;
      double alpha = -1.0;  // FH & AHCAL relative weight
      double gamma = -1.0;
      //double MIP_to_GeV_conversion_factor = 12.83;
      
      if(beamEnergy == 20) {
	// a = 0.0611934; b = 0.0183451;
	//a = 0.0630539 ;b = 0.0120932;
	a = 0.0604318 ;b = 0.0307894;
	alpha = 0.45; gamma = 13.205;
      }
      if(beamEnergy == 50) {
	// a = 0.0608286 ;b = 0.0136046;
	//a = 0.076075 ;b = 0.0116685;
	a = 0.0679195 ;b = 0.0324864;
	alpha = 0.40; gamma = 12.856;
      }
      if(beamEnergy == 80) {
	// a = 0.0622612 ;b = 0.0152219;
	//a = 0.0788491 ;b = 0.013591;
	a = 0.0683456 ;b = 0.0320886;
	alpha = 0.40; gamma = 13.1375;
      }
      if(beamEnergy == 100) {
	//a = 0.0786438 ;b = 0.0151615;
	a = 0.0677498 ;b = 0.031738;
	alpha = 0.40; gamma = 13.38;
      }
      if(beamEnergy == 120) {
	// a = 0.0600868 ;b = 0.018315;
	//a = 0.0794755 ;b = 0.0174122;
	a = 0.068558 ;b = 0.0314515;
	alpha = 0.40; gamma = 13.38;
      }
      if(beamEnergy == 200) {
	//a = 0.0802285 ;b = 0.0178579;
	//a = 0.0681734 ;b = 0.031085;
	a = 0.0678221 ;b = 0.0308716;
	alpha = 0.40; gamma = 13.635;
      }
      if(beamEnergy == 250) {
	// a = 0.0802285 ;b = 0.0178579;
	// a = 0.0804709 ;b = 0.0182122;
	a = 0.0678221 ;b = 0.0308716;
	alpha = 0.40; gamma = 13.756;
      }
      if(beamEnergy == 300) {
	//a = 0.0844364 ;b = 0.0148193;
	a = 0.0703497 ;b = 0.0293021;
	alpha = 0.40; gamma = 13.7266;
      }
      
      Gen_leak_EE_2->Fill(rechitEnergySum_EE,energyLeakTransverseEE);
      Gen_leak_FH_2->Fill(rechitEnergySum_FH,energyLeakTransverseFH);

      // Leak_vs_EE[shower_start_index]->Fill(rechitEnergySum_EE,energyLeakTransverseEE);
      // Leak_vs_FH[shower_start_index]->Fill(rechitEnergySum_FH,energyLeakTransverseFH);

      // Leak_vs_EE[shower_start_index]->Fill(rechitEnergySum_EE,LEAK);
      // Leak_vs_FH[shower_start_index]->Fill(rechitEnergySum_FH,LEAK);

      // double tot_ = (rechitEnergySum+rechitEnergySumAHCAL);
      // alpha = 0.40; gamma = 12.856; // For 50 GeV specifically
      double tot_ = beamEnergy;
      // int AH_frac = ((a*rechitEnergySumAHCAL)/tot_)*100;
      // int FH_frac = ((b*rechitEnergySum_FH)/tot_)*100;
      // int AH_frac = ((a*rechitEnergySumAHCAL));
      // int FH_frac = ((b*rechitEnergySum_FH));

      //double sigma2_FB = (rechitEnergySumAHCAL+rechitEnergySum_FH);
      // double sigma2_FB = 1.0;

      //double MIP_to_GeV_conversion_factor = 11.214;
      // double MIP_to_GeV_conversion_factor = 9.51;
      // double MIP_to_GeV_conversion_factor = 13.7;

      double MIP_to_GeV_conversion_factor = gamma;
      double FH_Gev_Scale = (rechitEnergySum_FH/MIP_to_GeV_conversion_factor);
      double AH_Gev_Scale = (rechitEnergySumAHCAL/MIP_to_GeV_conversion_factor);
      // double AH_Gev_Scale = rechitEnergySumAHCAL;
      double full_energy = FH_Gev_Scale+(alpha*AH_Gev_Scale);
      // double full_energy = FH_Gev_Scale+AH_Gev_Scale;

      // RecEn[shower_start_index]->Fill(full_energy + energyLeakTransverseEE + energyLeakTransverseFH + energyLeakTransverseAH); // Total rechit energy+ tot trans leakage
      
      // WtComp[shower_start_index]->Fill(rechitEnergySum_EE ,rechitEnergySum_FH); // Niramay. EE vs FH - weighted
      // GoodStat[COMP]->Fill(rechitEnergySum_EE ,rechitEnergySum_FH);
      
    }
    
    if(DEBUG) cout<<"Point hotel bravo"<<endl;

    //if(isRegion3 && shower_start_index>0) {
    if(isRegion3) {
      // double MIP_to_GeV = 57.6;
      // double MIP_to_GeV = 60.56;
      // double alpha = 0.4;
      // // double beta = 4.4;
      // double beta = 4.9;

      double alpha = -1.0; // EE & FH + AHCAL relative weight
      double beta = -1.0; // FH & AHCAL relative weight
      double gamma = -1.0; // FH & AHCAL relative weight
      
      if(beamEnergy == 20) {
	beta = 4.8; alpha = 0.45; gamma = 54.15;
      }
      if(beamEnergy == 50) {
	beta = 5.3; alpha = 0.40; gamma = 62.92;
      }
      if(beamEnergy == 80) {
	beta = 5.0; alpha = 0.40; gamma = 63.737;
      }
      if(beamEnergy == 100) {
	beta = 4.9; alpha = 0.40; gamma = 64.41;
      }
      if(beamEnergy == 120) {
	beta = 5.0; alpha = 0.40; gamma = 65.812;
      }
      if(beamEnergy == 200) {
	beta = 4.5; alpha = 0.40; gamma = 63.3;
      }
      if(beamEnergy == 250) {
	beta = 5.6; alpha = 0.40; gamma = 73.76;
      }
      if(beamEnergy == 300) {
	beta = 5.5; alpha = 0.40; gamma = 73.567;
      }

      // beta = 5.3; alpha = 0.40; gamma = 62.92;
      double MIP_to_GeV = gamma;
      // double tot_E_MIPs = rechitEnergySum_EE + beta*(rechitEnergySum_FH+(alpha*rechitEnergySumAHCAL));
      double EE_FH_MIPs = rechitEnergySum_EE + beta*(rechitEnergySum_FH);
      //double tot_E_gev = tot_E_MIPs/MIP_to_GeV;
      double EE_FH_gev = EE_FH_MIPs/MIP_to_GeV;
      double EE_gev = rechitEnergySum_EE/MIP_to_GeV;
      double FH_gev = (beta*rechitEnergySum_FH)/MIP_to_GeV;
      double AH_gev = rechitEnergySumAHCAL/MIP_to_GeV ;
      double tot_E_gev = EE_gev + FH_gev + AH_gev;

      Gen_leak_EE_1->Fill(rechitEnergySum_EE,energyLeakTransverseEE);
      Gen_leak_FH_1->Fill(rechitEnergySum_FH,energyLeakTransverseFH);

      // Leak_vs_EE[shower_start_index]->Fill(rechitEnergySum_EE,energyLeakTransverseEE);
      // Leak_vs_FH[shower_start_index]->Fill(rechitEnergySum_FH,energyLeakTransverseFH);

      // Leak_vs_EE[shower_start_index]->Fill(rechitEnergySum_EE,LEAK);
      // Leak_vs_FH[shower_start_index]->Fill(rechitEnergySum_FH,LEAK);

      // RecEn[shower_start_index]->Fill(tot_E_gev + energyLeakTransverseEE + energyLeakTransverseFH + energyLeakTransverseAH); // Total rechit energy+ tot trans leakage
      
      // WtComp[shower_start_index]->Fill(rechitEnergySum_EE ,beta*rechitEnergySum_FH); // Niramay. EE vs FH - weighted
      // GoodStat[COMP]->Fill(rechitEnergySum_EE ,rechitEnergySum_FH);

      if(tot_E_gev < 100) {
	// h_rechit_energy_EE_FHAHCAL_EH_gev_DEBUG->Fill(EE_gev,(FH_gev+AH_gev));
	// h_shower_start_reg3_DEBUG->Fill(shower_lambda_);
      }      

    }

    if(DEBUG) cout<<"Point hotel charlie"<<endl;
    if(shower_start_index>=0){
      // EE_FH_Leak[shower_start_index]->Fill(energyLeakTransverseEE,energyLeakTransverseFH); // Niramay
      // EE_Leak[shower_start_index]->Fill(energyLeakTransverseEE);
      // FH_Leak[shower_start_index]->Fill(energyLeakTransverseFH);
      // TotLeak[shower_start_index]->Fill(energyLeakTransverseEE + energyLeakTransverseFH + energyLeakTransverseAH + energyLeakLongitudinal + energyLeakResidual);
      // TotLeak[shower_start_index]->Fill(energyLeakTransverseEE + energyLeakTransverseFH + energyLeakTransverseAH); // total trans leakage
      float TotRecEn = 0;	// Total rechit energy
      float WtRecEn=0;		// Weighted rechit energy

      for(int i=0;i<40;i++){
	TotRecEn += RechitEn_layer[i];
	WtRecEn += RechitEn_layer[i];
      }
      // RecEn[shower_start_index]->Fill(TotRecEn); // Total rechit energy
      // WtComp[shower_start_index]->Fill(rechitEnergySum_EE ,beta*rechitEnergySum_FH); // Niramay. EE vs FH - weighted
    }
    // h_total_sim_energy->Fill(energyLostEE+energyLostFH+energyLostBH+energyLostBeam+energyLostOutside);
    if(DEBUG) cout<<"DEBUG: End of Event = "<<jentry+1<<endl;
    if(DEBUG) cout<<"DEBUG: ****************** "<<endl;
    if(DEBUG && jentry > 5) return;
    // if(DEBUG) return;
    // if(shower_start_index < 0)
    //   cout<<jentry+1<<endl;
    // if(region_1_classified_events > 20) break;
  } // loop over entries

  cout<<"Got Out "<<jentry<<endl;
  Long64_t total_events = (region_1_classified_events+region_2_classified_events+region_3_classified_events+non_classified_events);
  cout<<"Events with zero hits in AHCAL = "<<ahc_zeroHit<<endl;
  cout<<"MIP like events = "<<((float)region_1_classified_events*100.0)/total_events<<"%"<<endl;
  cout<<"shower start in EE = "<<((float)region_3_classified_events*100.0)/total_events<<"%"<<endl;
  cout<<"shower start in FH = "<<((float)region_2_classified_events*100.0)/total_events<<"%"<<endl;
  cout<<"Non-classified events = "<<((float)non_classified_events*100.0)/total_events<<"%"<<endl;
  //cout<<"Sum = "<<(region_1_classified_events+region_2_classified_events+region_3_classified_events+non_classified_events)<<endl;           
  cout<<"Sum = "<<total_events<<endl;

  
  // cout<<"Got Out "<<jentry<<endl;
  // cout<<"Events with zero hits in AHCAL = "<<ahc_zeroHit<<endl;
  // cout<<"MIP like events = "<<region_1_classified_events<<endl;
  // cout<<"shower start in EE = "<<region_3_classified_events<<endl;
  // cout<<"shower start in FH = "<<region_2_classified_events<<endl;
  // cout<<"Non-classified events = "<<non_classified_events<<endl;
  // cout<<"Sum = "<<(region_1_classified_events+region_2_classified_events+region_3_classified_events+non_classified_events)<<endl;

  if(E_beam < 0) {
    cout<<"E_beam negative!!!"<<endl;
    return;
  }
}

int MyComp(int ss , float* lambda)
{
  if(ss<0) return(-1);
  if(lambda[ss]<0.35) return(0);
  if(lambda[ss]<0.75) return(1);
  if(lambda[ss]<1.03) return(2);
  if(lambda[ss]<1.43) return(3);
  if(lambda[ss]<2.7) return(4);
  else return(5);
}
